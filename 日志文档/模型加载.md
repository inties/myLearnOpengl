## 模型加载

这一节教程创建了Model类和Mesh类，前者使用Assimp库加载各种格式的模型数据，转化为自定义的Mesh对象中的数据，并向外提供绘制该模型的接口。后者定义了Mesh类，定义了Mesh对象的构造方法，并提供了绘制Mesh对象的接口。



绘制之前，需要将数据传入shader，包括：

顶点属性、uniform变量

Mesh类当中存储了绘制某个网格所需要的几乎所有数据，全部的顶点属性和部分uniform变量



#### 绑定

纹理对象、VBO和VAO都是GPU当中存储的数据，而将它们传输给shader，都需要先完成绑定。



OpenGL 是一个状态机，绑定是通过函数（如 glBindBuffer、glBindTexture、glBindVertexArray）设置当前上下文中的“活动对象”。绑定后，后续的操作（如**数据上传**、绘制或 **Shader 访问**）会作用于这个被绑定的对象。**每个类型的对象都有对应的绑定点**（Binding Point），绑定点可以看作是 OpenGL 中某个功能的“插槽”。

>**插槽就像电源插座**：你有一堆电器（资源，比如缓冲对象或纹理），而 OpenGL 提供了一些插座（绑定点）。当你把电器插到一个插座上时，这个插座就“激活”了这个电器，后续的操作（比如调节电器的开关）都会作用于这个插进去的电器。



#### **绑定步骤的共性和区别**



| **方面**           | **VBO**                      | **VAO**              | **纹理**                     |
| ------------------ | ---------------------------- | -------------------- | ---------------------------- |
| **绑定函数**       | glBindBuffer                 | glBindVertexArray    | glBindTexture                |
| **绑定目标**       | GL_ARRAY_BUFFER              | GL_VERTEX_ARRAY      | GL_TEXTURE_2D 等             |
| **绑定后作用**     | 指定操作的缓冲区             | 激活顶点数据配置     | 指定纹理单元的纹理           |
| **多对象支持**     | 可同时存在多个 VBO，逐个绑定 | 一次只能绑定一个 VAO | 支持多个纹理单元绑定不同纹理 |
| **与 Shader 关系** | 通过 VAO 间接关联 Attribute  |                      |                              |



OpenGL 需要知道具体操作哪个缓冲区，因为程序中可能有多个 VBO（如一个存储位置，一个存储颜色）。



VAO 是一个“状态容器”，记录了 VBO 的绑定状态和**顶点属性的布局**（如位置、步长、偏移等）。

绑定 VAO 后，后续的绘制调用（如 glDrawArrays 或 glDrawElements）会**使用 VAO 中保存的配置**。绑定 VAO 会**激活**一组预定义的顶点数据状态，直接供渲染管线和 Shader 使用。VAO 绑定的 VBO 数据在绘制时自动传递给 Shader 的 Attribute 变量，无需额外手动干预。







纹理绑定的流程：

纹理单元是管理多个纹理的“插槽”，**是纹理目标如GL_TEXTURE_2D的容器**，而纹理目标GL_TEXTURE_2D是活动对象，是绑定点，通过绑定纹理目标到纹理对象上，能够管理该纹理对象。在激活某个纹理单元后，glBindTexture(GL_TEXTURE_2D, textureID)这个绑定操作将会把纹理对象放入“插槽”。**将纹理对象绑定到当前激活单元的指定目标**（如`GL_TEXTURE_2D`）。







- 将指定的纹理对象绑定到某个纹理单元（如 GL_TEXTURE0），表示当前操作的目标是这个纹理。
- 需要配合 glActiveTexture(GL_TEXTURE0 + n) 指定具体的纹理单元，因为 OpenGL 支持多个纹理同时使用。
- 绑定后，Shader 可以通过 Uniform 变量（如 sampler2D）访问这个纹理。
- **纹理目标（如`GL_TEXTURE_2D`）**：定义纹理类型，是绑定的“目标类型”。
- **纹理单元（如`GL_TEXTURE0`）**：管理多个纹理的“插槽”，需通过`glActiveTexture`激活。
- **正确绑定流程**：先激活纹理单元，再绑定目标类型的纹理对象。



#### 为什么绑定是必须的

1. 状态机的设计

   OpenGL 是基于状态机的 API，绑定是将对象与当前状态关联的桥梁。没有绑定，OpenGL 无法知道要操作或使用哪个对象。

2. 多对象管理

   程序中可能同时存在多个 VBO、VAO 或纹理对象，绑定明确指定当前操作的对象，避免混淆

3. 数据流控制

   绑定确保数据从 GPU 内存正确传递到渲染管线和 Shader。例如，VAO 绑定后，管线知道从哪些 VBO 读取数据；纹理绑定后，Shader 知道从哪个单元采样。





绑定是将 GPU 中的数据对象（VBO、VAO、纹理）与 OpenGL 渲染管线或 Shader 连接起来的关键步骤。VBO 绑定指定数据缓冲区，VAO 绑定激活顶点状态，纹理绑定关联采样器单元。虽然它们的目标和细节不同，但核心思想都是通过绑定明确“当前使用哪个对象”，从而确保数据正确传递并在 Shader 中可用。这种机制体现了 OpenGL 灵活但显式的设计哲学。
