## 光照

#### 基础光照

* 在一个立方体上实现phong shading效果，光源为点光源
  * 在世界空间中计算lightDir、viewDir，两者需要记得归一化为单位向量
  * 对一个3D立方体来讲，**每个顶点应该有三个方向不同的法向量**。分别在绘制不同面的时候使用。
  * 使用法线矩阵，这里是model3*3部分逆矩阵的转置，将法向量变换到世界空间



注意：

通过顶点属性指针绑定顶点属性后，要启用顶点属性。

```
glEnableVertexAttribArray(0);
```



#### 材质

材质让每个物体对光照做出不同的响应。这样子能够很容易在一个光照的场景中给每个物体一个独特的外观

<u>**物体的颜色是材质和光照的共同结果**</u>



* 在OpenGL中，**材质(Material)** 是描述物体表面对光照反应的一组属性，它决定了物体如何与环境光、漫反射光和镜面光交互。

  * **ambient材质向量**定义了在环境光照下这个表面反射的是什么颜色，通常与表面的颜色相同。**diffuse材质向量**定义了在漫反射光照下表面的颜色。漫反射颜色（和环境光照一样）也被设置为我们期望的物体颜色。**specular材质向量**设置的是表面上镜面高光的颜色（或者甚至可能反映一个特定表面的颜色）。最后，shininess影响镜面高光的散射/半径。

  * ![image-20250221231607732](E:\myLearnOpengl\日志文档\光照.assets\image-20250221231607732.png)

  * ```
    struct Material {
        vec3 ambient;    // 环境光反射颜色（通常与物体固有色相同）材质对环境光的反射属性。它决定了材质对环境光的反射程度。
        vec3 diffuse;    // 漫反射颜色（直接影响物体表面主色调）材质对漫反射光的反射属性。它决定了材质对漫反射光的反射程度。
        vec3 specular;   // 镜面高光颜色（金属类物体常为亮白色）
        float shininess; // 反光度（控制高光斑点大小，值越大斑点越小）
    };
    
    
    
    ```

* **光源属性**定义了光源本身的特性，由环境光、漫反射光和高光三个分量。它决定了光如何与物体材质交互。与材质属性共同作用时，会产生最终的渲染效果。

  * 环境光照通常被设置为一个比较低的强度，因为我们不希望环境光颜色太过主导。光源的漫反射分量通常被设置为我们希望光所具有的那个颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为`vec3(1.0)`

  * ```
    
    struct Light {
        vec3 position;
    
        vec3 ambient;
        vec3 diffuse;
        vec3 specular;
    };
    ```

* **材质属性与光源属性分离**，允许单独调整物体特性（如金属感）和光照条件（如暖光/冷光）。

  * 材质属性需要与光源属性结合计算最终颜色：

  * ```
    // 环境光分量 = 光源环境色 * 材质环境色
    vec3 ambient = light.ambient * material.ambient;
    
    // 漫反射分量 = 光源漫反射色 * (光线夹角 * 材质漫反射色)
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    
    // 镜面反射分量 = 光源镜面色 * (视线反射夹角^反光度 * 材质镜面色)
    vec3 specular = light.specular * (pow(spec, material.shininess) * material.specular);
    
    ```




***

#### 光照贴图

​	为了精细地控制物体的材质，可以对物体应用光照贴图，它包括漫反射贴图和镜面光贴图。在片段着色器中采样光照贴图，得到该片段处的材质漫反射属性和镜面光属性



* 因为环境光颜色在几乎所有情况下都等于漫反射颜色，所以我们认为材质的环境光属性等于漫反射贴图的采样得到的漫反射属性。
* 通过使用镜面光贴图我们可以可以对物体设置大量的细节，比如物体的哪些部分需要有**闪闪发光**的属性，我们甚至可以设置它们对应的强度。镜面光贴图能够在漫反射贴图之上给予我们更高一层的控制。
* 使用**Photoshop**或**Gimp**之类的工具，将漫反射纹理转换为镜面光纹理还是比较容易的，只需要剪切掉一些部分，将图像转换为黑白的，并增加亮度/对比度就好了。



***

### 光源/投光物

本节介绍了平行光、点光源、聚光灯的实现

* 在本节中，光源属性存储在片段着色器中的light结构体中。

  * 点光源：

  * ```
    struct Light {
        vec3 position;  
    
        vec3 ambient;
        vec3 diffuse;
        vec3 specular;
    
    //衰减系数，衰减公式
        float constant;一般取1，常数
        float linear;一次项系数
        float quadratic;二次项系数
    };
    ```

  * 衰减公式 ：$F=\frac{1}{K_1+K_2*d+K_3*d^2}$

  * 聚光灯：

  * ```
    struct Light {
        vec3  position;
        vec3  direction;
        float innerCutOff;//切光角余弦值，用于判定着色点是否被聚光灯照亮
        float outerCutOff;//外切光角余弦值
        
        vec3 ambient;
        vec3 diffuse;
        vec3 specular;
    
        float constant;
        float linear;
        float quadratic;
    };
    
    ```



计算着色点能否被聚光灯照亮的算法：

![light_casters_spotlight_angles](E:\myLearnOpengl\日志文档\光照.assets\light_casters_spotlight_angles.png)



将$\theta$的余弦值和切光角的余弦值比较，判定着色点是否可以被照亮

为了使得聚光边缘能够平滑地过渡：

$\theta$小于内切角时能够完全被照亮，大于外切角时完全不被照亮，在内切角和外切角之间时，接收光照的强度为一个过渡值。通过下面公式计算衰减：
$$
I=\frac{\theta-\gamma}{\beta-\gamma}
$$
其中分别为内外切角的余弦值

这是**线性插值**的方法，也可以使用其他方法



***

### 多光源

​	场景中存在多个光源时，对于每一个光源，它对片段的贡献颜色将会加到片段的输出颜色向量上。所以场景中的每个光源都会计算它们各自对片段的影响，并结合为一个最终的输出颜色。

​	GLSL中的函数和C函数很相似，它有一个函数名、一个返回值类型，如果函数不是在main函数之前声明的，我们还必须在代码文件顶部声明一个原型。我们对每个光照类型都创建一个不同的函数：定向光、点光源和聚光

​	多光源的情况下，光源属性很多，为uniform变量赋值的过程冗长而容易出错，**应该尝试使用UBO解决问题**。



##### 如何让聚光灯投影出纹理：

为了让聚光灯打在物体上，映出一片图案，像电影投影仪投影到荧幕上一样，应该如何实现：

​	要实现聚光灯投出图案，关键是要能找到聚光灯前方任意一点的纹理坐标。

​	聚光灯光源前方锥形范围会受光，如果用一个垂直于聚光灯发射方向的平面挡住光线，则会得到一块圆形的图案。离光源远近不同，图案大小不同，但图案形状不变。沿同一光线传播路径的所有点共享相同的纹理坐标，确保投影图案在空间中的一致性。因此这条光线决定了纹理坐标的值。我们可以使用向量描述这条光线：着色点的位置减去光源位置，再归一化，这个计算可以在视图空间完成。这个向量有两个自由度，我们可以直观地建立起它的x,y坐标（如果是在视图空间）和纹理之间的映射关系。

​	由于聚光灯只能打出一个锥形范围的光，因此x,y坐标都只能被限制在[-sin($\theta/2$)，sin($\theta/2$)]范围内，纹理坐标范围为[0,1]，为正确地采样需要线性变换后才能正好映射到纹理坐标。

​	后续可以思考：这个方法也可以将聚光灯的图案投影在曲面上，实现将平面纹理投射在曲面上。这可能有助于平面纹理UV到曲面纹理UV算法的设计。

