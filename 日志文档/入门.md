## 入门





### **着色器数据传递**

#### **着色器间数据传递**

- in类型和out类型的变量负责着色器间的数据流动

#### **通过****uniform****变量传递数据**

- uniform类型的变量是在某个着色器中声明的，但却是全局的，数据可以直接从cpu传给任意uniform变量
- glGetUniformLocation(shaderProgram,     "ourColor") 找到变量索引
- gluniform（）函数为其添加数据

VBO数据链接到顶点属性

- 绑定VBO到gl_array_buffer     （缓冲目标）
- 通过缓冲目标输入数据到VBO
- 通过顶点属性指针，链接缓冲目标和顶点属性

 

 

 

### **纹理**

#### **纹理的属性设置**

通过glTexParameteri()函数进行设置

##### **纹理环绕方式设置**

 

##### **纹理过滤方法设置**

纹理坐标属于0-1之间，采样时将纹理坐标映射到纹理图上，由于不一定映射到纹理图的像素中心。

当纹理图分辨率高或者低时，采用合适的过滤算法比较重要，例如最近邻采样或者双线性插值等

- 采样一张低分辨率的图像时，可以采用最近邻或者双线性插值
- 采样高分辨率图像时，通常使用Mipmap，并使用三线性插值

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

对图像进行”缩小过滤“，即采样高分辨率图像时 GL_TEXTURE_MIN_FILTER，使用mipmap并且线性插值

 

 

 

 

#### **Mipmap**

根据物体的远近在同一纹理的不同分辨率副本上采样

##### **使用原因**

- 节省内存
- 得到更准确的结果

##### **Mipmap****中的过滤**

- 原因

避免切换不同层级mipmap时出现的生硬变化

- 方式

Near或者linar

 

#### **通过纹理单元为着色器绑定多个纹理**

当一个fs中uniform声明了多个纹理采样器对象，可以通过纹理单元绑定多个纹理

##### **步骤**

- 激活某个纹理单元，将纹理绑定到纹理单元上
- 使用glUniform1i（）将纹理单元序号赋值给uniform sample2D对象中，即为纹理采样器分配一个位置值。默认位置值为0，即默认分配为GL_TEXTURE0





***



### **矩阵变换**

通过glm库，可以方便地创建变换矩阵，并对顶点进行变换

  ```
  
  glm::mat4 trans;
  trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));
  trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));//构建一个复合变换的矩阵，先缩放后旋转，
  
  
  unsigned int transformLoc = glGetUniformLocation(ourShader.ID, "transform"); glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));
  //需要利用指针变换trans矩阵，让它变成符合opengl要求的形式
  
  
  
  ```

***



### 坐标变换

1. **GLM矩阵体系构建**
    使用GLM数学库分别创建：
   - **模型矩阵**：通过`glm::rotate`/`translate`/`scale`控制物体空间变换
   - **观察矩阵**：采用`glm::lookAt`构建摄像机视角
   - **投影矩阵**：运用`glm::perspective`实现透视投影
2. **矩阵传递机制**
    将MVP矩阵体系（Model-View-Projection）通过`glUniformMatrix4fv`统一传输至着色器，完成顶点坐标的规范化设备坐标（NDC）转换
3. **动态渲染控制**
   - 在渲染循环中实时更新模型矩阵的旋转分量，实现物体绕轴自转
   - 通过矩阵平移分量差异，**批量**生成空间位置不同的物体实例
   - 采用单次顶点数据绑定配合多矩阵参数传递，优化实例化渲染效率

![image-20250220184214366](E:\myLearnOpengl\日志文档\入门.assets\image-20250220184214366.png)